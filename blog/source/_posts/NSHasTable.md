---
title: NSHasTable NSMapTable
date: 2019-01-04 22:12:10
categories:
- iOS
tags:
---

将对象添加到容器时(NSSet, NSArray, NSDictionary)，会对该对象的引用计数+1

`NSHashTable`是可变的,没有不可变的对应类 
`NSHashTable`可以持有成员的弱引用 
`NSHashTable`可以在加入成员时进行copy操作 
`NSHashTable`可以存储任意的指针,通过指针来进行相等性和散列检查 



NSMapTable是NSDictionary的通用版本,NSMapTable具有下面特性:
NSMapTable是可变的,没有不可变的类 
NSMapTable可以持有键和值的弱引用,当键或值当中的一个被释放时,整个这一项就会被移除掉 
NSMapTable可以在加入成员时进行copy操作 
NSMapTable可以存储任意的指针,通过指针来进行相等性和散列检查 


##### NSDictionary 的局限性
由于对象存储在特定位置，`NSDictionary `中要求` key` 的值不能改变（否则 object 的位置会错误）。为了保证这一点，`NSDictionary` 会始终复制 `key` 到自己的私有空间。

这个 `key` 的复制行为也是` NSDictionary` 如何工作的基础，但这也有一个限制：你只能使用 OC 对象作为 `NSDictionary `的 `key`，并且必须支持 `NSCopying` 协议。此外，`key` 应该是小且高效的，以至于复制的时候不会对 CPU 和内存造成负担。

这意味着，NSDictionary 中真的只适合将值类型的对象作为 key（如简短字符串和数字）。并不适合自己的模型类来做对象到对象的映射。

http://www.isaced.com/post-235.html



哈希表的本质是一个数组，数组中每一个元素称为一个箱子，箱子中存放的是键值对。

哈希表的存储过程如下:

1. 根据 key 计算出它的哈希值 h。
2. 假设箱子的个数为 n，那么这个键值对应该放在第 **(h % n)** 个箱子中。
3. 如果该箱子中已经有了键值对，就使用开放寻址法或者拉链法解决冲突。

在使用拉链法解决哈希冲突时，每个箱子其实是一个链表，属于同一个箱子的所有键值对都会排列在链表中。

哈希表还有一个重要的属性: 负载因子(load factor)，它用来衡量哈希表的 **空/满** 程度，一定程度上也可以体现查询的效率，计算公式为:

> 负载因子 = 总键值对数 / 箱子个数

负载因子越大，意味着哈希表越满，越容易导致冲突，性能也就越低。因此，一般来说，当负载因子大于某个常数(可能是 1，或者 0.75 等)时，哈希表将自动扩容。

哈希表在自动扩容时，一般会创建两倍于原来个数的箱子，因此即使 key 的哈希值不变，对箱子个数取余的结果也会发生改变，因此所有键值对的存放位置都有可能发生改变，这个过程也称为重哈希(rehash)。

哈希表的扩容并不总是能够有效解决负载因子过大的问题。假设所有 key 的哈希值都一样，那么即使扩容以后他们的位置也不会变化。虽然负载因子会降低，但实际存储在每个箱子中的链表长度并不发生改变，因此也就不能提高哈希表的查询性能。

哈希表存在的两个问题:

1. 如果哈希表中本来箱子就比较多，扩容时需要重新哈希并移动数据，性能影响较大。
2. 如果哈希函数设计不合理，哈希表在极端情况下会变成线性表，性能极低。



链接：https://juejin.im/post/57a3e43e8ac247005f19117e

