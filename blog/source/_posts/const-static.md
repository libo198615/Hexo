---
title: const static
date: 2019-01-03 17:24:33
categories:
- iOS
tags:
---

##### const

- const用来修饰右边的基本变量或指针变量
- 被修饰的变量只读，不能被修改

##### static

- 修饰局部变量

保证局部变量永远只初始化一次，在程序的运行过程中永远只有一份内存, 生命周期类似全局变量了，但是作用域不变。
```
-(void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event
{    //声明一个局部变量i
    int i = 0;    //每次点击view来到这个方法时让i自增
    i ++;    //打印结果
    NSLog(@"i=%d",i);
}
```
输出日志如下：
```
i=1
i=1
i=1
....
```
```
-(void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event
{    //声明一个局部变量i
    static  int i = 0;    //每次点击view来到这个方法时让i自增
    i ++;    //打印结果
    NSLog(@"i=%d",i);
}
```
输出日志如下：
```
i=1
i=2
i=3
i=4
i=5
....
```

再看一个例子：

```objective-c
- (void)viewDidLoad {
    [super viewDidLoad];
    

    [self a]; // 2
    [self a]; // 3
    [self a]; // 4
    [self b]; // 2
    [self b]; // 3
    
}

- (void)a {
    static int a = 1;
    a ++;
    NSLog(@"%d",a);
}

- (void)b {
    static int a = 1;
    a ++;
    NSLog(@"%d",a);
}
```

由于限定了作用域，a 和 b 中的static变量可以重名。相当于两个变量，它们的值互不影响。

```objective-c
Test *test1 = [[Test alloc] init];
[test1 logStaticA]; // 2
Test *test2 = [[Test alloc] init];
[test2 logStaticA]; // 3
```



同时，在局部变量内定义的static变量，自动称为了静态变量，生命周期同APP，所以当某个对象释放后再重新生成并调用上面的方法，a的值还是从上次的值开始，而不是从1开始。可以理解为，某个对象内部的静态变量的值，一直跟随这个类，无论这个对象被声明几次，或成名成几个不同名称的对象.

- 修饰全局变量

使全局变量的作用域仅限于当前文件内部，即当前文件内部才能访问该全局变量。

- 修饰函数
static修饰函数时，被修饰的函数被称为静态函数，使得外部文件无法访问这个函数，仅本文件可以访问。

##### extern

这个单词翻译过来是“外面的、外部的”。顾名思义，它的作用是声明外部全局变量。这里需要特别注意`extern`只能声明，不能用于实现。
在开发中，我们通常会单独抽一个类来管理一些全局的变量或常量，下面来看看逼格比较高的一种做法：

我们可以在.h文件中extern声明一些全局的常量

//声明一些全局常量
```
extern NSString * const name;
extern NSInteger const count;
```
然后在.m文件中去实现

###import //实现
```
NSString * const name = @"王五";
NSInteger const count = 3;
```
这样，只要导入头文件，就可以全局的使用定义的变量或常量。





从分配内存空间看：

全局变量、静态局部变量、静态全局变量都在静态存储区分配空间，而局部变量在栈分配空间。

全局变量本身就是静态存储方式，静态全局变量当然也是静态存储方式。这两者在存储方式上没有什么不同。区别在于非静态全局变量的作用域是整个源程序，当一个源程序由多个源文件组成时，非静态的全局变量在各个源文件中都是有效的。而静态全局变量则限制了其作用域，即只在定义该变量的源文件内有效，在同一源程序的其他源文件中不能使用它。由于静态全局变量的作用域局限于一个源文件内，只能为该源文件内的函数公用，因此可以避免在其他源文件中引起错误。

1、静态变量会被放在程序的静态数据存储区里，这样可以在下一次调用的时候还可以保持原来的赋值。这一点是他与栈变量和堆变量的区别，单例模式就是利用这个机制。

2、变量用static告知编译器，自己仅仅在变量的作用域范围内可见。这一点是他与全局变量的区别。

从以上分析可以看出，把局部变量改变为静态变量后是改变了他的存储方式，即改变了他的生命周期。把全局变量改变为静态变量后是改变了他的作用域，限制了他的使用范围，

