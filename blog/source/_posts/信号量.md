---
title: 信号量
date: 2019-01-02 20:46:33
categories:
- iOS
tags:
---

`dispatch_semaphore_signal`是发送一个信号，自然会让信号总量加1，
`dispatch_semaphore_wait`等待信号，当信号总量少于0的时候就会一直等待，否则就可以正常的执行，并让信号总量-1

```objective-c
// 创建队列组
dispatch_group_t group = dispatch_group_create();   
// 创建信号量，并且设置值为10
dispatch_semaphore_t semaphore = dispatch_semaphore_create(10);   
dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);   
for (int i = 0; i < 100; i++)   
{   
    // 由于是异步执行的，所以每次循环Block里面的dispatch_semaphore_signal根本还没有执行就会执行dispatch_semaphore_wait，从而semaphore-1.当循环10此后，semaphore等于0，则会阻塞线程，直到执行了Block的dispatch_semaphore_signal 才会继续执行
    dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);   
    dispatch_group_async(group, queue, ^{   
        NSLog(@"%i",i);   
        sleep(2);   
        // 每次发送信号则semaphore会+1，
        dispatch_semaphore_signal(semaphore);   
    });   
}

```
在开发中我们需要等待某个网络回调完之后才执行后面的操作
```objective-c

_block BOOL isok = NO;  

dispatch_semaphore_t sema = dispatch_semaphore_create(0);  
Engine *engine = [[Engine alloc] init];  
[engine queryCompletion:^(BOOL isOpen) {  
    isok = isOpen;  
    dispatch_semaphore_signal(sema);  
} onError:^(int errorCode, NSString *errorMessage) {  
    isok = NO;  
    dispatch_semaphore_signal(sema);  
}];  

dispatch_semaphore_wait(sema, DISPATCH_TIME_FOREVER);  
// 创建的时候信号量为 0 ，执行到此时要等待
// todo what you want to do after net callback
```
