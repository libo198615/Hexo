---
title: HTTP
date: 2019-01-20 10:35:10
categories:

- 计算机基础知识
tags:
---

### 四层模型
1. 应用层

HTTP HTTPS FTP DNS  xmpp

2. 传输层

TCP UDP

不同的程序通过不同的端口获取数据 

"传输层"的功能，就是建立"端口到端口"的通信。相比之下，"网络层"的功能是建立"主机到主机"的通信。只要确定主机和端口，我们就能实现程序之间的交流。因此，Unix系统就把主机+端口，叫做"套接字"（socket）。有了它，就可以进行网络应用程序开发了。 

get pust put delete header options

3. 网络层

   IP

4. 链路层

----

#### HTTP

持久连接：

```
connection : keep-alive 客户端期许采用持久连接
time : 20 持续20秒内不会进行4次挥手关闭
max : 10 最多 多少个http请求
```

持久连接的结束：

```
content-length : 1024 server端告知客户端数据的总大小
chunked 最后一次的chunked是空
```





### 一条HTTP请求的流程

![](http://ww1.sinaimg.cn/large/006tNc79ly1g5k3q6a6v4j30r60nsgzu.jpg)

1. 客户端发送请求
2. 传输层，TCP把从应用层接收到的HTTP请求报文进行分割，并在各个报文上打上标记序号及端口号后转发给网络层。
3. 在网络层（IP 协议），增加作为通信目的地的 MAC 地址后转发给链路层。

---

### 请求报文格式

- 请求行
  分为三个部分：请求方法、请求地址 和 协议及版本
- 请求头
- 空行
- 请求体

![](http://ww2.sinaimg.cn/large/006tNc79ly1g5k3rxtx5mj313e0m21kx.jpg)

### 通用首部字段

```
Cache-Control
Connection:  Keep-Alive // 默认持久连接  
Date: 报文创建时间
Transfer-Encoding: 编码格式
```

### 请求首部字段

```
Accept // 首部字段可通知服务器，用户代理能够处理的媒体类型及媒体类型的相对优先级
Accept-Language // 用来告知服务器用户代理能够处理的自然语言集
Authorization //  是用来告知服务器，用户代理的认证信息（证书值）。通常，想要通过服务器认证的用户代理会在接收到返回的 401 状态码响应后
Host // 会告知服务器，请求的资源所处的互联网主机名和端口号
If-Modified-Since //  字段指定的日期时间后，资源发生了更新，服务器会接受请求
Range
```



### 响应报文格式

- 状态行
  由HTTP协议版本号， 状态码， 状态消息
- 消息报头
  用来说明客户端要使用的一些附加信息
- 空行
- 响应正文

![](http://ww1.sinaimg.cn/large/006tNc79ly1g5k3sze28jj31180ig7cp.jpg)

### 响应首部字段

```
ETag
Server 告知客户端当前服务器上安装的 HTTP 服务器应用程序的信息
Content-Type 说明了实体主体内对象的媒体类型
Last-Modified 指明资源最终修改的时间
Set-Cookie
```

### 

### URL 格式

![](http://ww3.sinaimg.cn/large/006tNc79ly1g5k3tzn4p6j30k503sglm.jpg)



#### socket

当使用socket创建套接字后，底层会建立一个包含 本地IP 端口号 目的IP 端口号 的数据结构，然后TCP发起连接请求，即三次握手。

出于性能的考虑，心跳包一般由客户端发送，一般只发送非常简单的包或空包。一个原因是防火墙会把一定时间内没有数据交互的连接断开。这个时候就需要心跳包维持长连接了。服务器在一定时间内没有收到客户端发送的心跳包，可以判断客户离线了，客户端在一定时间内没有收到服务器的响应包，可以判定服务器挂了

#### GET POST

`GET` 请求参数以？分割拼接到URL后面，`POST` 请求参数在Body里面

`GET` 参数长度限制2048个字符， `POST` 一般没有限制

GET :

​	安全性：`GET`获取资源，执行不会引起`server`端的变化。还有`HEAD`,`OPTIONS`
​    幂等：同一个请求方法执行多次和执行一次的效果完全相同(GET请求返回的数据可能不同，但GET请求本身是不变的)
   可缓存：

#### UDP

用户数据报协议

无连接：不建立连接和释放连接
尽最大努力交付：不保证可靠传输
面向报文：既不合并也不拆分，报文小不合并，报文大也不拆分

### TCP

传输控制协议

面向连接
可靠传输：超时重传，确认丢失(丢弃重复报文)，
面向字节流：报文的拆分和合并
流量控制：滑动窗口协议
拥塞控制



---

### TCP

![](http://ww4.sinaimg.cn/large/006tNc79ly1g5k3vudnkgg311w0lcju4.gif)

***为什么TCP客户端最后还要发送一次确认呢？***
如果使用的是两次握手建立连接，假设有这样一种场景，客户端发送了第一个连接请求，只是因为在网络结点中滞留的时间长了，由于TCP的客户端迟迟没有收到确认报文，以为服务器没有收到，此时重新向服务器发送这条报文，此后客户端和服务器经过两次握手完成连接，传输数据，然后关闭连接。此时此前滞留的那一次连接请求到达了服务器，这个报文本该是失效的，但是，两次握手的机制将会让客户端和服务器再次建立连接，这将导致不必要的错误和资源的浪费。

##### 四次挥手

![](http://ww3.sinaimg.cn/large/006tNc79ly1g5k3wq9j9rg30iy0aoq5k.gif)

1. 客户端进程发出连接释放报文，并且停止发送数据。
2. 服务器收到连接释放报文，发出确认报文。这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。
3. 服务器将最后的数据发送完毕后，就向客户端发送连接释放报文。
4. 客户端收到服务器的连接释放报文后，必须发出确认。注意此时TCP连接还没有释放，必须经过2MSL（最长报文段寿命）的时间后。服务器只要收到了客户端发出的确认，立即进入CLOSED状态。服务器端的socket先断开，不可以再读取数据。2MSL后，如果没有收到服务器发送的连接释放报文，说明客户端发送的确认断开报文被服务器成功接收，客户端进入close状态

***为什么客户端最后还要等待2MSL？***
第一，保证客户端发送的最后一个ACK报文能够到达服务器，因为这个ACK报文可能丢失，站在服务器的角度看来，我已经发送了FIN+ACK报文请求断开了，客户端还没有给我回应，应该是我发送的请求断开报文它没有收到，于是服务器又会重新发送一次，而客户端就能在这个2MSL时间段内收到这个重传的报文，接着给出回应报文，并且会重启2MSL计时器。

第二，防止类似与“三次握手”中提到了的“已经失效的连接请求报文段”出现在本连接中。客户端发送完最后一个确认报文后，在这个2MSL时间中，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失。这样新的连接中不会出现旧连接的请求报文。

***如果已经建立了连接，但是客户端突然出现故障了怎么办？***
TCP还设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75分钟发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。

#### ACK

默认情况下，接收方每收到两个 TCP 数据包，就要发送一个确认消息。"确认"的英语是 acknowledgement，所以这个确认消息就简称 ACK。

ACK 携带两个信息。

- 期待要收到下一个数据包的编号

- 接收方的接收窗口的剩余容量

发送方有了这两个信息，再加上自己已经发出的数据包的最新编号，就会推测出接收方大概的接收速度，从而降低或增加发送速率。

##### 数据包的遗失处理

TCP 协议可以保证数据通信的完整性，这是怎么做到的？

前面说过，每一个数据包都带有下一个数据包的编号。如果下一个数据包没有收到，那么 ACK 的编号就不会发生变化。

举例来说，现在收到了4号包，但是没有收到5号包。ACK 就会记录，期待收到5号包。过了一段时间，5号包收到了，那么下一轮 ACK 会更新编号。如果5号包还是没收到，但是收到了6号包或7号包，那么 ACK 里面的编号不会变化，总是显示5号包。这会导致大量重复内容的 ACK。

如果发送方发现收到三个连续的重复 ACK，或者超时了还没有收到任何 ACK，就会确认丢包，即5号包遗失了，从而再次发送这个包。通过这种机制，TCP 保证了不会有数据包丢失。



---

### 负责传输的`IP`协议

IP（Internet Protocol）网际协议位于网络层。`IP`其实是一种协议的名称。不要和`IP`地址搞混

`IP` 协议的作用是把各种数据包传送给对方。而要保证确实传送到对方那里，则需要满足各类条件。其中两个重要的条件是 `IP` 地址和 `MAC` 地址

`IP `地址指明了节点被分配到的地址，`MAC` 地址是指网卡所属的固定地址。`IP` 地址可变换，但 `MAC 地址`基本上不会更改。

规定网络地址的协议，叫做IP协议。它所定义的地址，就被称为IP地址。 

联网上的每一台计算机，都会分配到一个IP地址。这个地址分成两个部分，前一部分代表网络，后一部分代表主机。比如，IP地址172.16.254.1，这是一个32位的地址，假定它的网络部分是前24位（172.16.254），那么主机部分就是后8位（最后的那个1）。处于同一个子网络的电脑，它们IP地址的网络部分必定是相同的，也就是说172.16.254.2应该与172.16.254.1处在同一个子网络。 

所谓"子网掩码"，就是表示子网络特征的一个参数。它在形式上等同于IP地址，也是一个32位二进制数字，它的网络部分全部为1，主机部分全部为0。比如，IP地址172.16.254.1，如果已知网络部分是前24位，主机部分是后8位，那么子网络掩码就是11111111.11111111.11111111.00000000，写成十进制就是255.255.255.0。 

IP协议的作用主要有两个，一个是为每一台计算机分配IP地址，另一个是确定哪些地址在同一个子网络。 

---

### DNS
`DNS`服务是和 HTTP 协议一样位于应用层的协议。它提供域名到 IP 地址之间的解析服务。
DNS解析请求采用UDP数据报，53端口，且明文
DNS解析：
	递归查询：本地DNS -> 顶级DNS -> 根DNS
	迭代查询：本地DNS -> 顶级DNS(某DNS知道，你去问它吧) -> 某DNS

DNS解析和HTTP没有关系，DNS解析发生在HTTP建立之前，DNS解析请求使用UDP数据报，端口号53

防止DNS劫持

httpDNS：使用HTTP协议向DNS服务器的80窗口进行解析，不在是UDP的明文
长连接：

### 各协议和HTTP的关系

![](http://ww3.sinaimg.cn/large/006tNc79ly1g5k41lz5icj30u017tajf.jpg)


### HTTP 状态码
- 200 OK

- 301 重定向

- 302 临时重定向

- 401 需要认证

- 403 不允许访问

- 404 服务器上没有请求的资源

---

### 代理
![](http://ww3.sinaimg.cn/large/006tNc79ly1g5k42a2omoj30x90a0wfn.jpg)

代理服务器的基本行为就是接收客户端发送的请求后转发给其他服务器。每次通过代理服务器转发请求或响应时，会追加写入 Via 首部信息.使用代理服务器的理由有：利用缓存技术减少网络带宽的流量，组织内部针对特定网站的访问控制，以获取访问日志为主要目的，等等。

---

### 端口号

同一个端口不会同时出现，传输层通过辨认端口号来确认应用。但是只靠端口号识别通信是不够的。需要采取五个信息来识别一个通信，分别是源 IP 地址，目标 IP 地址，协议号，源端口号，目标端口号。两个包中只要任何一个信息不同就不是同一个通信。

---



### 网关

![](http://ww1.sinaimg.cn/large/006tNc79ly1g5k4376z3nj30pr0633yu.jpg)

利用网关可以由 HTTP 请求转化为其他协议通信

---

### MAC地址 

网卡的固定地址，独一无二 



---

### 缓存

- Last-Modified/If-Modified-Since

Last-Modified标注的最后修改只能精确到秒级, 如果某些文件在1秒钟以内被修改多次的话, 它将不能准确标注文件的修改时间(无法及时更新文件).
如果某些文件会被定期生成, 而内容其实并没有发生任何变化, 但Last-Modified却改变了, 这种情况其实应该返回304而不是200加上资源文件.

ETag便是为解决以上问题而生的. ETag描述了一个资源文件内容的唯一标识符, 如果两个文件具有相同的ETag, 那么表示这两个文件的内容完全一样, 即使它们各自的更新/创建时间不同.


通过页码分页初始化

这个问题很容易出现, 比如一个用户有400+好友, 一个网络请求把400+都拉下来肯定不现实, 客户端势必是要做个分页拉取的. 直觉上, 我们可以像普通的分页请求一样, APP直接传页码让后台分页返回数据似乎就能搞定这个问题. 然而实际情况是: 最好不要这样做.
考虑以下情况, 总共200+左右的好友数据, 每次分页拉取50个.
第一次拉取时本地页码为1, 拉取0~49个好友成功后, 本地页码更新为2.
第二次拉取50~99个好友时失败了, 本地页码不更新依然为2.
如果此时用户刚好在网页端/Android端又添加了50个新好友, 于是后台页码后移, 本来处在第一页的0~49现在变成了50~99, 而第二页的50~99现在变成了100~149. 所以, 当我们通过本地页码2去拉取数据时拉取到的数据其实是早就获取过的数据, 本次拉取只是在浪费时间, 浪费流量而已, 而新增的那些好友显然这次是拉取不到了.
上面只是小问题, 反过来, 如果用户当时不是在添加好友而是在删除好友(假设删除的就是0~49), 那么后台页码前移, 第二页的50~99现在变成了第一页, 而我们的本地页码还是2, 那么原来的第二页数据肯定就拿不到了, 同时第一页本来该删除的数据却被缓存下来了, 这便是数据错乱, 大问题!

通过URL数组分页初始化

普通的页码拉取的方式行不通, 那么分页拉取应该如何搞? 回答这个问题, 我们可以看看浏览器是如何初始化一个网页的, 模仿到底嘛.
当浏览器首次向服务器请求网页数据时, 服务器的首次返回数据其实是一个HTML文件, 这个HTML文件只包含一些基本的页面展示, 而页面内嵌的Image/JS/CSS等等都是作为一个个HTML标签而不是直接一次性返回的. 浏览器在拿到这个HTML后一边渲染一边解析, 一旦解析到一个Image/JS/CSS它就会通过标签引用的URL向服务器获取相应的Image/JS/CSS, 获取到相应资源以后填充到合适的位置以提供展示/操作.
如果我们把一个TableView当成一个HTML页面看的话, 那么列表内部展示的一个个Cell其实就相当于HTML中的一个个Image标签, Cell展示的数据源其实就是这些标签引用的URL对应的图片.
不过和HTML请求标签元素的情况不同, Cell的数据源不像图片那样动辄上百KB甚至几MB, 所以我们没必要针对每个标签都分别发起一次请求, 一次性拉取几十上百个数据源完全没有问题.
那么按照这个思路, 针对初始化的处理会分成两步:

拉取待初始化列表元素的的URL数组(也就是各个Model的主键)
根据上面的URL数组分页拉取列表元素

仍然以上面的情况举例, 我们看看这种思路能不能解决上面的问题:
初始化一个200人的好友列表, 首先我们会拉取这200个好友的用户Id, 假设是[0...199]. 拉取第一页时我们传入[0...49]个Id从服务器拉取50个好友, 拉取成功后从初始化Id列表删除这50个Id, 初始化Id列表变成[50...199], 此时有50个新好友被添加到服务器, 服务器数据变动, 但是本地的初始化列表没变, 所以我们可以继续拉取到[50...99]部分的数据, 以此类推. 显然, 我们不会有任何冗余的数据请求.
反过来, 如果[0...49]部分的好友被删除, 服务器数据变动, 但是本地列表因为没有变动, 后续的[50...199]自然也是能准确拉取到的, 不会发生数据丢失.
但是这样的做法依然存在弊端, 因为本地的初始化列表不做变更, 那么服务器在初始化过程中新增的数据我们是不知道的, 自然也就不会去拉取, 初始化的数据就少了. 反过来, 初始化过程已拉取的数据如果被删除了, 客户端依然不知情, 缓存中就会有无效数据. 那么, 如何解决这两个问题呢?
一个简单的解决方法是: 在某次分页拉取的返回数据中, 服务器不仅返回对应的数据, 同时也返回一下此时最新的Id数组. 本地根据这个最新的Id数组进行比对, 多出来的部分显然就是新增的, 我们将这部分更新到初始化列表继续拉取. 而少掉的部分显然就是被删除的, 我们从数据库中删除这部分无效数据.
这样会多一部分Id数组的开销, 但是相比它解决的问题而言, 这点开销微不足道.



---



### HTTPS

![](http://ww3.sinaimg.cn/large/006tNc79ly1g5k43oj5k1j30mq0ke75o.jpg)

1. 客户端发起HTTPS请求 

用户在浏览器里输入一个https网址，然后连接到server的443端口。 信息包含：支持的加密算法，随机数C

2. 服务端的配置 

采用HTTPS协议的服务器必须要有一套数字证书，可以自己制作，也可以向组织申请。区别就是自己颁发的证书需要客户端验证通过，才可以继续访问，而使用受信任的公司申请的证书则不会弹出提示页面。这套证书其实就是一对公钥和私钥。如果对公钥和私钥不太理解，可以想象成一把钥匙和一个锁头，只是全世界只有你一个人有这把钥匙，你可以把锁头给别人，别人可以用这个锁把重要的东西锁起来，然后发给你，因为只有你一个人有这把钥匙，所以只有你才能看到被这把锁锁起来的东西。 

3. 传送证书 

这个证书其实就是公钥，只是包含了很多信息，如证书的颁发机构，过期时间等等。还包含 随机数S，和所选定的加密算法

4. 客户端解析证书 

这部分工作是有客户端的TLS来完成的，首先会验证公钥是否有效，比如颁发机构，过期时间等等，如果发现异常，则会弹出一个警告框，提示证书存在问题。

5. 传送加密信息 

这部分传送的是用证书加密后的随机值，目的就是让服务端得到这个随机值，以后客户端和服务端的通信就可以通过这个随机值来进行加密解密了。 
会话密钥 = random S  + random C + 预主密钥

6. 服务端解密信息 

服务端用私钥解密后，得到了客户端传过来的随机值(私钥)，然后把内容通过该值进行对称加密。所谓对称加密就是，将信息和私钥通过某种算法混合在一起，这样除非知道私钥，不然无法获取内容，而正好客户端和服务端都知道这个私钥，所以只要加密算法够彪悍，私钥够复杂，数据就够安全。 

7. 传输加密后的信息 

这部分信息是服务段用私钥加密后的信息，可以在客户端被还原 

8. 客户端解密信息 

客户端用之前生成的私钥解密服务端传过来的信息，于是获取了解密后的内容。整个过程第三方即使监听到了数据，也束手无策。对称加密：需要对加密和解密使用相同密钥的加密算法。由于其速度快，对称性加密通常在消息发送方需要加密大量数据时使用。 



每一个使用 HTTPS 的服务器都必须去专门的证书机构注册一个证书，证书中存储了用权威机构私钥加密的公钥。这样客户端用权威机构的公钥解密就可以了。

这个公钥不用传输，会直接内置在各大操作系统(或者浏览器)的出厂设置里。

CA的作用就是颁发证书，颁发证书其实就是使用CA的私钥对证书请求签名文件进行签名，其次，CA颁发的证书浏览器要信任，浏览器只需要用CA的公钥进行验签成功就表示这个证书是合法可信的，这就需要浏览器内置CA的公钥，也就是内置CA的证书。一般来说，操作系统都会内置权威CA的证书

为了确保原始证书没有被篡改，我们可以在传递证书的同时传递证书的哈希值。那么修改后的数据在解密后，就不可能通过哈希。

常见的非对称加密算法有RSA和ECC（椭圆曲线算法）。

SSL结合了这两种加密算法的优点，通过非对称加密来协商对称加密的密钥，握手成功之后便可使用对称加密来做加密通信，对于RSA来说，客户端是用RSA的公钥把预主密钥加密后传给服务器，服务器再用私钥来解密，双方再通过相同的算法来生成会话密钥，之后的应用层数据就可以通过会话密钥来加密通信。

---

#### 粘包

tcp对两个数据报进行分割传输，接收方接收到了两个数据包，但是这两个数据包要么是不完整的，要么就是多出来一块，这种情况即发生了拆包和粘包。

发送方将两个数据报合并发送，接收端只收到一个数据包，由于TCP是不会出现丢包的，所以这一个数据包中包含了发送端发送的两个数据包的信息，这种现象即为粘包。这种情况由于接收端不知道这两个数据包的界限，所以很难处理



### 抓包

抓取https包的时候,青花瓷会要求使用者对抓包的设备(手机或其他设备),安装一个证书,安装这个证书的时候,其实是安装了一个根证书(允许颁发CA的一个证书机构的根证书),当你安装了该根证书之后,该证书机构颁发的其他证书,默认都会被你的系统所信任,这个就是青花瓷完成https抓包的一个重要前提!! 



1. 客户端对服务器发送请求,由于青花瓷做了代理,请求被青花瓷拦截,处理,青花瓷将客户端带的随机数和加密算法处理,然后返回自己的证书通过客户端校验,获取到客户端提交的请求参数等数据, 

2. 青花瓷作为客户端去请求刚刚Client想要请求的Server,然后,Server会和青花瓷完成上面讲的那个完整的校验,并且读取青花瓷带来的具体请求,返回正常的数据结果. 

3. 青花瓷得到服务器数据的返回结果之后,开始继续和过程1中的Client以服务器的身份,去做处理,首先收到客户端的随机数和加密算法,自己生成一个随机数和选择一个客户端的加密算法,然后青花瓷会返回一个伪造的CA证书,然后Client在这个伪造的证书的基础上,和青花瓷通信,然后青花瓷再和Server通信,成了一个中间人的角色,这样,整个过程的数据传输,都被青花瓷给监听到了 

在此,中间人攻击的过程就完成了 

##### 防止抓包 

当进行网络请求的时候,客户端判断当前是否设置了代理，判断是否有 Via字段。如果设置了代理,不允许进行访问。



#### 表单

```
content-type：multipart/form-data

POST http://www.example.com HTTP/1.1
Content-Type:multipart/form-data; boundary=----WebKitFormBoundaryrGKCBY7qhFd3TrwA
 
------WebKitFormBoundaryrGKCBY7qhFd3TrwA
Content-Disposition: form-data; name="text"
 
title
------WebKitFormBoundaryrGKCBY7qhFd3TrwA
Content-Disposition: form-data; name="file"; filename="chrome.png"
Content-Type: image/png
 
PNG ... content of chrome.png ...
------WebKitFormBoundaryrGKCBY7qhFd3TrwA--
```



