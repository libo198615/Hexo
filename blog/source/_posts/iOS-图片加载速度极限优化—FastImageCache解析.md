---
title: iOS图片加载速度极限优化—FastImageCache解析
date: 2019-01-06 20:35:14
categories:
- iOS
tags:
---


http://blog.cnbang.net/tech/2578/



### iOS从磁盘加载一张图片，使用UIImageVIew显示在屏幕上，需要经过以下步骤：
    
1. 从磁盘拷贝数据到内核缓冲区
2. 从内核缓冲区复制数据到用户空间
3. 生成UIImageView，把图像数据赋值给UIImageView
4. 如果图像数据为未解码的PNG/JPG，解码为位图数据
5. CATransaction捕获到UIImageView layer树的变化
6. 主线程Runloop提交CATransaction，开始进行图像渲染
	- 6.1 如果数据没有字节对齐，Core Animation会再拷贝一份数据，进行字节对齐。
	- 6.2 GPU处理位图数据，进行渲染。
    
FastImageCache分别优化了2,4,6.1三个步骤：
    
1. 使用mmap内存映射，省去了上述第2步数据从内核空间拷贝到用户空间的操作。
2. 缓存解码后的位图数据到磁盘，下次从磁盘读取时省去第4步解码的操作。
3. 生成字节对齐的数据，防止上述第6.1步CoreAnimation在渲染时再拷贝一份数据。

    
### 内存映射
    
平常我们读取磁盘上的一个文件，上层API调用到最后会使用系统方法read()读取数据，内核把磁盘数据读入内核缓冲区，用户再从内核缓冲区读取数据复制到用户内存空间，这里有一次内存拷贝的时间消耗，并且读取后整个文件数据就已经存在于用户内存中，占用了进程的内存空间。
    
FastImageCache采用了另一种读写文件的方法，就是用mmap把文件映射到用户空间里的虚拟内存，文件中的位置在虚拟内存中有了对应的地址，可以像操作内存一样操作这个文件，相当于已经把整个文件放入内存，但在真正使用到这些数据前却不会消耗物理内存，也不会有读写磁盘的操作，只有真正使用这些数据时，也就是图像准备渲染在屏幕上时，虚拟内存管理系统VMS才根据缺页加载的机制从磁盘加载对应的数据块到物理内存，再进行渲染。这样的文件读写文件方式少了数据从内核缓存到用户空间的拷贝，效率很高。
    
### 解码图像
    
一般我们使用的图像是JPG/PNG，这些图像数据不是位图，而是是经过编码压缩后的数据，使用它渲染到屏幕之前需要进行解码转成位图数据，这个解码操作是比较耗时的，并且没有GPU硬解码，只能通过CPU，iOS默认会在主线程对图像进行解码。很多库都解决了图像解码的问题，不过由于解码后的图像太大，一般不会缓存到磁盘，SDWebImage的做法是把解码操作从主线程移到子线程，让耗时的解码操作不占用主线程的时间。
    
FastImageCache也是在子线程解码图像，不同的是它会缓存解码后的图像到磁盘。因为解码后的图像体积很大，FastImageCache对这些图像数据做了系列缓存管理。另外缓存的图像体积大也是使用内存映射读取文件的原因，小文件使用内存映射无优势，内存拷贝的量少，拷贝后占用用户内存也不高，文件越大内存映射优势越大。
    
### 字节对齐
    
Core Animation在图像数据非字节对齐的情况下渲染前会先拷贝一份图像数据，官方文档没有对这次拷贝行为作说明，模拟器和Instrument里有高亮显示“copied images”的功能，但似乎它有bug，即使某张图片没有被高亮显示出渲染时被copy，从调用堆栈上也还是能看到调用了CA::Render::copy_image方法：
    
     [![](http://blog.cnbang.net/wp-content/uploads/2015/02/fastImageCache1.png)](http://blog.cnbang.net/wp-content/uploads/2015/02/fastImageCache1.png)
    
为了性能，底层渲染图像时不是一个像素一个像素渲染，而是一块一块渲染，数据是一块块地取，就可能遇到这一块连续的内存数据里结尾的数据不是图像的内容，是内存里其他的数据，可能越界读取导致一些奇怪的东西混入，所以在渲染之前CoreAnimation要把数据拷贝一份进行处理，确保每一块都是图像数据，对于不足一块的数据置空。大致图示：(pixel是图像像素数据，data是内存里其他数据)
    
     [![fastImageCache2](http://blog.cnbang.net/wp-content/uploads/2015/02/fastImageCache2.png)](http://blog.cnbang.net/wp-content/uploads/2015/02/fastImageCache2.png)
   